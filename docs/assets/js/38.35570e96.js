(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{324:function(e,t,a){"use strict";a.r(t);var r=a(14),i=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"history"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#history"}},[e._v("#")]),e._v(" history")]),e._v(" "),t("h2",{attrs:{id:"background"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" background")]),e._v(" "),t("p",[e._v("The ghÅ«l "),t("a",{attrs:{href:"https://github.com/degory/ghul",target:"_blank",rel:"noopener noreferrer"}},[e._v("compiler"),t("OutboundLink")],1),e._v(" is a "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Self-hosting_(compilers)",target:"_blank",rel:"noopener noreferrer"}},[e._v("self-hosting compiler"),t("OutboundLink")],1),e._v(", capable of compiling itself from its own source code.")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Bootstrapping_(compilers)",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bootstrapping"),t("OutboundLink")],1),e._v(" a new compiler for a new language is a classic chicken-and-egg problem: you need a compiler to compile your new compiler, but that compiler doesnâ€™t exist yet.")]),e._v(" "),t("p",[e._v("The solution is to write the initial compiler in a language that does exist; then, once that compiler is sufficiently reliable, its source code must be translated into the new language, giving a compiler that can compile the new language, including its own source code. It's best to keep the initial compiler simple, for example by handling only a subset of the new language and producing unoptimized code. The smaller and simpler the initial compiler is, the less work is involved in translating it into the new language, making bootstrapping easier.")]),e._v(" "),t("h2",{attrs:{id:"tombstones"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tombstones"}},[e._v("#")]),e._v(" tombstones")]),e._v(" "),t("p",[e._v("When discussing bootstrapping, it's common to use "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Tombstone_diagram",target:"_blank",rel:"noopener noreferrer"}},[e._v("tombstone"),t("OutboundLink")],1),e._v(" diagrams. In a T shaped tombstone diagram, the T represents a particular version of a compiler. Within the T, three languages are named: the source language, the target language, and the implementation language. The target language is typically some kind of IL or machine language, but for a transpiler, the target language is source code.")]),e._v(" "),t("p",[e._v("For example, a compiler C that reads source in language S, translates it to language T, and is implemented in language I, would be depicted like this:")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-tombstone-example.drawio.svg",alt:"Example tombstone showing compiler for language S, targeting language T, written in language I"}})]),e._v(" "),t("h2",{attrs:{id:"the-l-compiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-l-compiler"}},[e._v("#")]),e._v(" the L compiler")]),e._v(" "),t("p",[e._v("ghÅ«l grew out of another language I designed, years before, named L, and I used L in the early stages of the ghÅ«l compiler development. The initial ghÅ«l compiler could in principle have been written in any pre-existing language with a compiler; I chose L because I knew I could easily make changes to the L language and compiler if needed to support the ghÅ«l bootstrap.")]),e._v(" "),t("p",[e._v("(Plus, why spend ages designing a programming language and building a compiler for it, if you're not going to use it to build "),t("em",[e._v("another")]),e._v(" compiler for a "),t("em",[e._v("another")]),e._v(" programming language you've invented? ðŸ˜‚)")]),e._v(" "),t("p",[e._v("Like the ghÅ«l compiler, the L compiler is self-hosting. It was originally written in C++ and I bootstrapped it manually by hand translating the C++ source into equivalent L. This tedious process was made easier by carefully sticking to an L-compatible subset of C++ when writing the initial C++ version of the L compiler.")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-L-compiler-bootstrap-from-C++.drawio.svg",alt:"bootstrapping the L compiler"}})]),e._v(" "),t("h2",{attrs:{id:"l-to-l-transpiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l-to-l-transpiler"}},[e._v("#")]),e._v(" L to L transpiler")]),e._v(" "),t("p",[e._v("The first version of the ghÅ«l compiler wasn't really a compiler and it didn't understand ghÅ«l. It was actually a simple L source code to L source code transpiler, written in L.")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-L-to-L-transpiler.drawio.svg",alt:"The L to L transpiling 'ghul compiler'"}})]),e._v(" "),t("p",[e._v("This transpiler was in part a strategic piece of scaffolding, intended to support the bootstrap process. I wanted to automate the process of transforming the compiler source code from L to ghÅ«l and so avoid the tedious hand-translation I'd had to do previously when bootstrapping the L compiler. Some parts of the L to L transpiler do survive in the real ghÅ«l compiler (the lexical analyzer and the parser), but the rest was discarded once the initial bootstrap was complete")]),e._v(" "),t("p",[e._v("I added a compiler driver to the L to L transpiler, so it could call the existing L compiler, passing in the L code it generated. The result was a compiler that consumed L source code and generated x64 machine code, but which also generated transpiled L source code as an intermediate step.")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-L-to-L-transpiler-with-L-compiler.drawio.svg",alt:"L compiler and the L to L transpiling 'ghul compiler'"}})]),e._v(" "),t("p",[e._v("This simple 'ghÅ«l compiler' still understood no ghÅ«l, performed no semantic analysis, and generated L source code as its 'object code'. It relied completely on the L compiler for semantic error detection and reporting and for x64 code generation.")]),e._v(" "),t("h2",{attrs:{id:"l-to-ghul-and-ghul-to-l-transpilers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l-to-ghul-and-ghul-to-l-transpilers"}},[e._v("#")]),e._v(" L to ghÅ«l and ghÅ«l to L transpilers")]),e._v(" "),t("p",[e._v("I enhanced the L to L transpiler so it could transpile L to ghÅ«l and ghÅ«l to L. The transpiler was still written in L and still relied on the L compiler as a backend to generate the x64 executable from transpiled the L code.")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-gh%C5%ABl-and-L-transpilers.drawio.svg",alt:"Transpilers handling both L and ghul"}})]),e._v(" "),t("h2",{attrs:{id:"first-ghul-bootstrap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#first-ghul-bootstrap"}},[e._v("#")]),e._v(" first ghÅ«l bootstrap")]),e._v(" "),t("p",[e._v("Then I passed the L source code of the ghÅ«l to L transpiler through the L to ghÅ«l transpiler, generating output in ghÅ«l. This yielded a ghÅ«l to L transpiler written in ghÅ«l:")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-gh%C5%ABl-self-hosting-transpiler.drawio.svg",alt:"Bootstrapping the ghÅ«l to L transpiler"}})]),e._v(" "),t("p",[t("strong",[e._v("This step is the first bootstrap")]),e._v(", and it's why I started with a transpiler: the source code of the ghÅ«l to L transpiler, which was originally L, has now been mechanically transformed into ghÅ«l. This new transpiler is written in ghÅ«l, and it can transpile itself into L: it has become self-hosting, albeit still dependent on the L compiler to generate machine code from L.")]),e._v(" "),t("h2",{attrs:{id:"net-backend"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#net-backend"}},[e._v("#")]),e._v(" .NET backend")]),e._v(" "),t("p",[e._v("Gradually, I integrated more semantic analysis into the ghÅ«l compiler: representations of classes, traits, methods, functions, variables, etc., along with corresponding error checking and reporting.")]),e._v(" "),t("p",[e._v("With the compiler now capable of constructing a detailed representation of input programs, I began implementing a .NET IL generation backend. I did this in stages, adding support for expressions and local variable definitions first, then working through the other more advanced language constructs.")]),e._v(" "),t("p",[e._v("I initially used scaffolding to test generated IL snippets, because the compiler wasn't capable of generating completely self-contained IL programs. As I implemented .NET IL for the various ghÅ«l language features, and the compiler became increasingly more capable, I guarded against regressions by building "),t("a",{attrs:{href:"https://github.com/degory/ghul/tree/main/integration-tests",target:"_blank",rel:"noopener noreferrer"}},[e._v("integration tests"),t("OutboundLink")],1),e._v(" as I went. The regression test runner started out as a collection of bash scripts, but as the compiler stabilized, I "),t("a",{attrs:{href:"https://github.com/degory/ghul-test",target:"_blank",rel:"noopener noreferrer"}},[e._v("rewrote it in ghÅ«l"),t("OutboundLink")],1),e._v(". The initial regression suite included tests asserting correct IL generation for all the different ghÅ«l language constructs as I implemented them. As soon as the compiler could generate code for complete programs, I added further integration tests exercising generated code execution.")]),e._v(" "),t("p",[e._v("I continued to maintain the transpilation to L source code backend alongside the .NET IL backend throughout this process, until the .NET IL backend was sufficiently complete and stable to self-host the compiler on .NET.")]),e._v(" "),t("p",[e._v("This phase was complicated by L's LLVM backend and by its standard library, with features like generic collections and file handling, which interfaced with glibc and were not source compatible with similar facilities in .NET. I needed to be able to use these facilities in the compiler source, and have the built compiler run on both glibc and .NET. I solved this by cloning a small subset of the .NET standard library in ghÅ«l, and then porting references to the L standard library in the ghÅ«l compiler to use this .NET library subset, thus enabling the compiler to be built on and target both L and .NET.")]),e._v(" "),t("h2",{attrs:{id:"full-self-hosting-on-net"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#full-self-hosting-on-net"}},[e._v("#")]),e._v(" full self-hosting on .NET")]),e._v(" "),t("p",[e._v("Finally, with the compiler reliably self-hosting on .NET, I removed the L transpilation backend and the .NET library subset, and the compiler was successfully bootstrapped onto .NET.")]),e._v(" "),t("p",[e._v("You can see this process in the Git history in the "),t("a",{attrs:{href:"https://github.com/degory/ghul",target:"_blank",rel:"noopener noreferrer"}},[e._v("ghÅ«l compiler repo"),t("OutboundLink")],1),e._v(", going all the way back to the initial commit.")])])}),[],!1,null,null,null);t.default=i.exports}}]);