(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{309:function(e,t,a){"use strict";a.r(t);var i=a(14),r=Object(i.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"history"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#history"}},[e._v("#")]),e._v(" history")]),e._v(" "),t("h2",{attrs:{id:"background"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" background")]),e._v(" "),t("p",[e._v("The ghūl "),t("a",{attrs:{href:"https://github.com/degory/ghul",target:"_blank",rel:"noopener noreferrer"}},[e._v("compiler"),t("OutboundLink")],1),e._v(" is a "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Self-hosting_(compilers)",target:"_blank",rel:"noopener noreferrer"}},[e._v("self-hosting compiler"),t("OutboundLink")],1),e._v(": it can compile itself from its own source code. Developing the self-hosting ghūl compiler required an initial "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Bootstrapping_(compilers)",target:"_blank",rel:"noopener noreferrer"}},[e._v("bootstrap"),t("OutboundLink")],1),e._v(". Bootstrapping a new compiler for a new language is a classic chicken-and-egg problem: you need a compiler to compile your new compiler, but that compiler doesn’t exist yet.")]),e._v(" "),t("p",[e._v("The solution is to write the initial compiler in an existing language. Once that compiler is sufficiently reliable, its source code must be somehow translated into the new language. This results in a compiler that can compile the new language including its own source code.")]),e._v(" "),t("p",[e._v("The discussions on bootstrapping use "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Tombstone_diagram",target:"_blank",rel:"noopener noreferrer"}},[e._v("tombstone diagrams"),t("OutboundLink")],1),e._v(". In a T shaped tombstone diagram, the T represents a particular version of a compiler. Within the T, three languages are named: the source language, the target language and the implementation language. The target language is typically some kind of IL or machine language, but for a transpiler the target language is source code.")]),e._v(" "),t("p",[e._v("For example a compiler C that reads source in language S, translates it to language T, and is implemented in language I, would be depicted like this:")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-tombstone-example.drawio.svg",alt:"Example tombstone showing compiler for language S, targeting language T, written in language I"}})]),e._v(" "),t("p",[e._v("To use compiler C, we need a compiler for source language I, and a machine to execute target code T. Provided we have those, we can compile C with the compiler for I, and when we run the resulting executable, it will consume source code written in S, and produce target code that will execute on T. If the compiler for I won't run on the machine that executes T, then compiler C is a "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Cross_compiler",target:"_blank",rel:"noopener noreferrer"}},[e._v("cross compiler"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")])]),e._v(" "),t("p",[e._v("I wrote the first version of the ghūl compiler in the L programming language - a language I designed and implemented a self-hosting compiler for previously.")]),e._v(" "),t("p",[e._v("Getting to this point required "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Bootstrapping_(compilers)",target:"_blank",rel:"noopener noreferrer"}},[e._v("bootstrapping"),t("OutboundLink")],1),e._v(" the compiler:  bootstrapping is the process of getting")]),e._v(" "),t("p",[e._v("Bootstrapping it now is routine: it's done by the CI/CD pipeline on every PR merge and release. However, the initial bootstrap was much more complex.")]),e._v(" "),t("p",[e._v('The initial bootstrap of a self-hosting compiler for a new programming language is a complex and challenging task due to the paradoxical nature of the process: the compiler, which translates code written in the new language into executable machine code, needs to be written in the new language it\'s supposed to compile, but no compiler exists that can compile it. This creates a "chicken-and-egg" problem where the first version of the compiler must be written in a different, already established language. Bootstrapping is the process of taking this initial non-self-hosting compiler and somehow translating it into a new compiler written in the new language and capable of compiling itself.')]),e._v(" "),t("p",[e._v("The initial bootstrap of ghūl involved several stages and I'll cover it in detail below.")]),e._v(" "),t("h2",{attrs:{id:"bootstrapping-the-l-compiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bootstrapping-the-l-compiler"}},[e._v("#")]),e._v(" bootstrapping the L compiler")]),e._v(" "),t("p",[e._v("The original basis for the compiler was written many years ago. I was a compiler for a language quite different from ghūl - a language I called L. This L compiler was originally written in C++, and compiled the L language to x64 assembly language. I manually bootstrapped the L compiler by hand translating its C++ source code into L. This was made easier (if no less tedious) by carefully sticking to an L-compatible subset of C++ when writing the L compiler.")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-L-compiler-bootstrap-from-C++.drawio.svg",alt:"bootstrapping the L compiler"}})]),e._v(" "),t("h2",{attrs:{id:"bootstrapping-the-ghul-compiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bootstrapping-the-ghul-compiler"}},[e._v("#")]),e._v(" bootstrapping the ghūl compiler")]),e._v(" "),t("p",[e._v("The first version of the ghūl compiler was written in a language named L. L was a language I designed a")]),e._v(" "),t("h3",{attrs:{id:"l-to-l-transpiler-written-in-l"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#l-to-l-transpiler-written-in-l"}},[e._v("#")]),e._v(" L to L transpiler written in L")]),e._v(" "),t("p",[e._v("A few years later, when I decided to design the ghūl programming language, I needed a new compiler. I wrote this first version of the ghūl compiler in L. Initially, this compiler was a simple source-level L to L transpiler, and did not understand the ghūl language at all:")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-L-to-L-transpiler.drawio.svg",alt:"The L to L transpiling 'ghul compiler'"}})]),e._v(" "),t("p",[e._v("As this simple 'ghūl compiler' performing no semantic analysis and generated L source code as its 'object code', it relied on the L compiler for semantic error detection and reporting and for x64 code generation.")]),e._v(" "),t("p",[e._v("The combination of this L to L transpiler plus the self hosting L compiler was an L compiler that produced x64 executables with an intermediate step of transpiled L as an intermediate language.")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-L-to-L-transpiler-with-L-compiler.drawio.svg",alt:"L compiler and the L to L transpiling 'ghul compiler'"}})]),e._v(" "),t("p",[e._v("Note we are running the transpiler and the compiler together in sequence as if the combination of the two was a single compiler. The input language of the transpiler is translated into the output language of the compiler. This is not yet bootstrapping, so we're not nesting the tombstone diagrams together as we would for a bootstrap.")]),e._v(" "),t("p",[e._v("This L-to-L transpiler was temporary scaffolding to support bootstrapping the ghūl compiler. It could in principle have been written any language with a compiler for the target architecture, but since I wrote the L compiler, choosing L meant I could make changes to the L language and compiler if needed to support the ghūl bootstrap.")]),e._v(" "),t("p",[e._v("The reason the initial transpiler translated L to L is that I needed it to be able to transpile itself, and to produce a language that a compiler already existed for. The plan being to use the transpiler to bootstrap itself from an existing language to the new language ghūl by re-writing its own source code in ghūl. I couldn't start with a transpiler written in ghūl, as no compiler would be able to compile it. Nor would there be any point in having the transpiler emit ghūl as again, no compiler would be able to compile this output. Once the transpiler was up and running, it could be modified to support ghūl input and output.")]),e._v(" "),t("h3",{attrs:{id:"ghul-to-l-transpiler-written-in-l"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ghul-to-l-transpiler-written-in-l"}},[e._v("#")]),e._v(" ghūl to L transpiler written in L")]),e._v(" "),t("p",[e._v("I then enhanced this L to L transpiler so it could transpile L to ghūl and ghūl to L. Both versions of this transpiler were still written in L and still relied on the L compiler as a backend to generate the x64 executable from transpiled the L code.")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-gh%C5%ABl-and-L-transpilers.drawio.svg",alt:"Transpilers handling both L and ghul"}})]),e._v(" "),t("h3",{attrs:{id:"transpiler-bootstrap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#transpiler-bootstrap"}},[e._v("#")]),e._v(" transpiler bootstrap")]),e._v(" "),t("p",[e._v("I passed the L source code of the ghūl to L transpiler through the L to ghūl transpiler, generating output in ghūl. This yielded a ghūl to L transpiler written in ghūl")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-gh%C5%ABl-self-hosting-transpiler.drawio.svg",alt:"Bootstrapping the ghūl to L transpiler"}})]),e._v(" "),t("p",[t("strong",[e._v("This step is the first bootstrap")]),e._v(": the source code of the ghūl to L transpiler that was L, has been transformed into ghūl, and so it can now transpile itself.")]),e._v(" "),t("p",[e._v("I enhanced the ghūl to L transpiler so it called the L compiler automatically, and this combination of ghūl to L transpiler followed by the self hosting L compiler became the self-hosting ghūl language compiler front end.")]),e._v(" "),t("p",[t("img",{attrs:{src:"bootstrap-all-transpilers.drawio.svg",alt:"All transpilers"}})]),e._v(" "),t("p",[e._v("However, this early version of the ghūl compiler was very crude and still depended on the L compiler for semantic analysis, error checking, and code generation.")]),e._v(" "),t("h3",{attrs:{id:"bootstrapping-from-l-backend-to-net-backend"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bootstrapping-from-l-backend-to-net-backend"}},[e._v("#")]),e._v(" bootstrapping from L backend to .NET backend")]),e._v(" "),t("p",[e._v("Gradually, I integrated more semantic analysis into the ghūl compiler. This addition included representations of classes, traits, methods, functions, variables, etc., along with corresponding error checking and reporting.")]),e._v(" "),t("p",[e._v("With the compiler now capable of constructing a detailed representation of input programs, I added a .NET IL generation backend. I maintained the L source code backend alongside the .NET IL backend until the .NET IL backend was sufficiently complete and stable to self-host the compiler on .NET. This phase was awkward due to L's LLVM backend and its standard library, with features like generic collections and file handling, which interfaced with glibc and were not source compatible with similar facilities in .NET. I solved this by building a small subset of the .NET standard library in L, and then porting references to the L standard library in the ghūl compiler to use this .NET library subset, thus enabling the compiler to be built on and target both L and .NET.")]),e._v(" "),t("p",[e._v("Finally, with the compiler reliably self-hosting on .NET, I removed the L transpilation backend and the .NET library subset, and the compiler was successfully bootstrapped onto .NET.")]),e._v(" "),t("p",[e._v("You can see this process in the Git history in the ghūl compiler repo, going all the way back to the initial commit.")])])}),[],!1,null,null,null);t.default=r.exports}}]);